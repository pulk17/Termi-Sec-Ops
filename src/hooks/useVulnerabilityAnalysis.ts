import { useState, useCallback } from 'react';
import { 
  VulnerabilityAnalysisService, 
  VulnerabilityAnalysisOptions, 
  VulnerabilityAnalysisResult, 
  AnalysisProgress,
  createVulnerabilityAnalysisService 
} from '@/lib/vulnerability-analysis';
import { ProjectInfo } from '@/lib/project-analyzer';
import { useSnyk } from './useSnyk';
import { toast } from 'sonner';

export interface UseVulnerabilityAnalysisOptions {
  onAnalysisProgress?: (progress: AnalysisProgress) => void;
  autoSaveResults?: boolean;
}

export interface UseVulnerabilityAnalysisReturn {
  // Analysis state
  isAnalyzing: boolean;
  analysisProgress: AnalysisProgress | null;
  lastAnalysisResult: VulnerabilityAnalysisResult | null;
  analysisHistory: VulnerabilityAnalysisResult[];
  
  // Analysis methods
  analyzeProject: (
    projectInfo: ProjectInfo,
    options?: Partial<VulnerabilityAnalysisOptions>
  ) => Promise<VulnerabilityAnalysisResult>;
  cancelAnalysis: () => void;
  clearResults: () => void;
  
  // Result management
  saveResult: (result: VulnerabilityAnalysisResult, name?: string) => void;
  loadResult: (id: string) => VulnerabilityAnalysisResult | null;
  deleteResult: (id: string) => void;
  exportResults: (result: VulnerabilityAnalysisResult, format?: 'json' | 'csv') => string;
  
  // Comparison and analysis
  compareResults: (result1: VulnerabilityAnalysisResult, result2: VulnerabilityAnalysisResult) => {
    newVulnerabilities: number;
    fixedVulnerabilities: number;
    severityChanges: Array<{
      vulnerability: string;
      oldSeverity: string;
      newSeverity: string;
    }>;
    scoreChange: number;
  };
  
  // Utilities
  service: VulnerabilityAnalysisService;
  error: string | null;
  clearError: () => void;
}

export const useVulnerabilityAnalysis = (
  options: UseVulnerabilityAnalysisOptions = {}
): UseVulnerabilityAnalysisReturn => {
  const { onAnalysisProgress, autoSaveResults = true } = options;
  const { client: snykClient } = useSnyk();

  // State
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [analysisProgress, setAnalysisProgress] = useState<AnalysisProgress | null>(null);
  const [lastAnalysisResult, setLastAnalysisResult] = useState<VulnerabilityAnalysisResult | null>(null);
  const [analysisHistory, setAnalysisHistory] = useState<VulnerabilityAnalysisResult[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [analysisController, setAnalysisController] = useState<AbortController | null>(null);

  // Create service instance with progress callback
  const service = createVulnerabilityAnalysisService((progress: AnalysisProgress) => {
    setAnalysisProgress(progress);
    if (onAnalysisProgress) {
      onAnalysisProgress(progress);
    }
  });

  // Load saved results from localStorage on initialization
  const loadSavedResults = useCallback(() => {
    try {
      const saved = localStorage.getItem('vulnerability-analysis-history');
      if (saved) {
        const parsed = JSON.parse(saved);
        setAnalysisHistory(parsed);
      }
    } catch (error) {
      console.warn('Failed to load saved analysis results:', error);
    }
  }, []);

  // Save results to localStorage
  const saveToStorage = useCallback((results: VulnerabilityAnalysisResult[]) => {
    try {
      localStorage.setItem('vulnerability-analysis-history', JSON.stringify(results));
    } catch (error) {
      console.warn('Failed to save analysis results:', error);
    }
  }, []);

  // Main analysis method
  const analyzeProject = useCallback(async (
    projectInfo: ProjectInfo,
    options: Partial<VulnerabilityAnalysisOptions> = {}
  ): Promise<VulnerabilityAnalysisResult> => {
    try {
      setError(null);
      setIsAnalyzing(true);
      setAnalysisProgress(null);
      
      // Create abort controller for cancellation
      const controller = new AbortController();
      setAnalysisController(controller);

      // Default analysis options
      const analysisOptions: VulnerabilityAnalysisOptions = {
        enableOSV: true,
        enableNpmAudit: projectInfo.packageManager === 'npm',
        enableSnyk: !!snykClient,
        snykClient: snykClient || undefined,
        severityThreshold: 'low',
        includeDevDependencies: true,
        maxConcurrentRequests: 10,
        ...options
      };

      // Run analysis
      const result = await service.analyzeProject(projectInfo, analysisOptions);
      
      // Update state
      setLastAnalysisResult(result);
      
      // Add to history
      const newHistory = [result, ...analysisHistory.slice(0, 9)]; // Keep last 10 results
      setAnalysisHistory(newHistory);
      
      // Auto-save if enabled
      if (autoSaveResults) {
        saveToStorage(newHistory);
      }

      // Show success message
      const { summary } = result;
      if (summary.totalVulnerabilities === 0) {
        toast.success('No vulnerabilities found! ðŸŽ‰');
      } else if (summary.criticalCount > 0) {
        toast.error(`Found ${summary.totalVulnerabilities} vulnerabilities including ${summary.criticalCount} critical`);
      } else if (summary.highCount > 0) {
        toast.warning(`Found ${summary.totalVulnerabilities} vulnerabilities including ${summary.highCount} high severity`);
      } else {
        toast.info(`Found ${summary.totalVulnerabilities} vulnerabilities (${summary.fixableCount} fixable)`);
      }

      return result;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Analysis failed';
      setError(errorMessage);
      
      setAnalysisProgress({
        stage: 'failed',
        progress: 0,
        message: errorMessage,
        scannedPackages: 0,
        totalPackages: 0
      });

      toast.error(errorMessage);
      throw error;

    } finally {
      setIsAnalyzing(false);
      setAnalysisController(null);
    }
  }, [service, snykClient, analysisHistory, autoSaveResults, saveToStorage]);

  // Cancel analysis
  const cancelAnalysis = useCallback(() => {
    if (analysisController) {
      analysisController.abort();
      setAnalysisController(null);
      setIsAnalyzing(false);
      setAnalysisProgress(null);
      toast.info('Analysis cancelled');
    }
  }, [analysisController]);

  // Clear results
  const clearResults = useCallback(() => {
    setLastAnalysisResult(null);
    setAnalysisHistory([]);
    setAnalysisProgress(null);
    setError(null);
    localStorage.removeItem('vulnerability-analysis-history');
    toast.info('Analysis results cleared');
  }, []);

  // Save result with custom name
  const saveResult = useCallback((result: VulnerabilityAnalysisResult, name?: string) => {
    const savedResult = {
      ...result,
      metadata: {
        savedAt: new Date(),
        customName: name,
        id: `analysis-${Date.now()}`
      }
    };

    const newHistory = [savedResult, ...analysisHistory.filter(r => r !== result)];
    setAnalysisHistory(newHistory);
    saveToStorage(newHistory);
    
    toast.success(`Analysis result saved${name ? ` as "${name}"` : ''}`);
  }, [analysisHistory, saveToStorage]);

  // Load result by ID
  const loadResult = useCallback((id: string): VulnerabilityAnalysisResult | null => {
    const result = analysisHistory.find(r => (r as any).metadata?.id === id);
    if (result) {
      setLastAnalysisResult(result);
      return result;
    }
    return null;
  }, [analysisHistory]);

  // Delete result
  const deleteResult = useCallback((id: string) => {
    const newHistory = analysisHistory.filter(r => (r as any).metadata?.id !== id);
    setAnalysisHistory(newHistory);
    saveToStorage(newHistory);
    toast.info('Analysis result deleted');
  }, [analysisHistory, saveToStorage]);

  // Export results
  const exportResults = useCallback((
    result: VulnerabilityAnalysisResult, 
    format: 'json' | 'csv' = 'json'
  ): string => {
    return VulnerabilityAnalysisService.exportResults(result, format);
  }, []);

  // Compare two analysis results
  const compareResults = useCallback((
    result1: VulnerabilityAnalysisResult,
    result2: VulnerabilityAnalysisResult
  ) => {
    const vulns1 = new Map(result1.unifiedVulnerabilities.map(v => [v.id, v]));
    const vulns2 = new Map(result2.unifiedVulnerabilities.map(v => [v.id, v]));

    // Find new vulnerabilities (in result2 but not in result1)
    const newVulnerabilities = Array.from(vulns2.keys()).filter(id => !vulns1.has(id)).length;

    // Find fixed vulnerabilities (in result1 but not in result2)
    const fixedVulnerabilities = Array.from(vulns1.keys()).filter(id => !vulns2.has(id)).length;

    // Find severity changes
    const severityChanges: Array<{
      vulnerability: string;
      oldSeverity: string;
      newSeverity: string;
    }> = [];

    vulns1.forEach((vuln1, id) => {
      const vuln2 = vulns2.get(id);
      if (vuln2 && vuln1.severity !== vuln2.severity) {
        severityChanges.push({
          vulnerability: vuln1.title,
          oldSeverity: vuln1.severity,
          newSeverity: vuln2.severity
        });
      }
    });

    // Calculate score change
    const scoreChange = result2.summary.securityScore - result1.summary.securityScore;

    return {
      newVulnerabilities,
      fixedVulnerabilities,
      severityChanges,
      scoreChange
    };
  }, []);

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Load saved results on mount
  React.useEffect(() => {
    loadSavedResults();
  }, [loadSavedResults]);

  return {
    // Analysis state
    isAnalyzing,
    analysisProgress,
    lastAnalysisResult,
    analysisHistory,
    
    // Analysis methods
    analyzeProject,
    cancelAnalysis,
    clearResults,
    
    // Result management
    saveResult,
    loadResult,
    deleteResult,
    exportResults,
    
    // Comparison and analysis
    compareResults,
    
    // Utilities
    service,
    error,
    clearError
  };
};

// Add React import for useEffect
import React from 'react';