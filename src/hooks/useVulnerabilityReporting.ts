import { useState, useCallback } from 'react';
import { 
  VulnerabilityReportGenerator, 
  VulnerabilityReport, 
  ReportOptions, 
  ChartData,
  createVulnerabilityReportGenerator 
} from '@/lib/vulnerability-reporting';
import { VulnerabilityAnalysisResult } from '@/lib/vulnerability-analysis';
import { toast } from 'sonner';

export interface UseVulnerabilityReportingOptions {
  autoSaveReports?: boolean;
  defaultFormat?: 'json' | 'csv' | 'html' | 'pdf' | 'markdown';
}

export interface SavedReport {
  id: string;
  name: string;
  format: string;
  generatedAt: Date;
  projectName: string;
  size: number;
  content: string;
}

export interface UseVulnerabilityReportingReturn {
  // Report generation
  isGenerating: boolean;
  currentReport: VulnerabilityReport | null;
  generateReport: (
    analysisResult: VulnerabilityAnalysisResult,
    options: ReportOptions
  ) => Promise<VulnerabilityReport>;
  
  // Report export
  isExporting: boolean;
  exportReport: (
    report: VulnerabilityReport,
    format?: 'json' | 'csv' | 'html' | 'pdf' | 'markdown'
  ) => Promise<string>;
  
  // Quick report generation
  generateQuickReport: (
    analysisResult: VulnerabilityAnalysisResult,
    format?: 'json' | 'csv' | 'html' | 'pdf' | 'markdown'
  ) => Promise<string>;
  
  // Report management
  savedReports: SavedReport[];
  saveReport: (report: VulnerabilityReport, name: string, format: string, content: string) => void;
  loadReport: (id: string) => SavedReport | null;
  deleteReport: (id: string) => void;
  clearAllReports: () => void;
  
  // Chart data generation
  generateChartData: (analysisResult: VulnerabilityAnalysisResult) => ChartData[];
  
  // Report templates
  getReportTemplates: () => Array<{
    name: string;
    description: string;
    options: Partial<ReportOptions>;
  }>;
  
  // Download utilities
  downloadReport: (content: string, filename: string, format: string) => void;
  
  // Utilities
  formatFileSize: (bytes: number) => string;
  validateReportOptions: (options: ReportOptions) => { valid: boolean; errors: string[] };
  error: string | null;
  clearError: () => void;
}

export const useVulnerabilityReporting = (
  options: UseVulnerabilityReportingOptions = {}
): UseVulnerabilityReportingReturn => {
  const { autoSaveReports = true, defaultFormat = 'html' } = options;

  // State
  const [isGenerating, setIsGenerating] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [currentReport, setCurrentReport] = useState<VulnerabilityReport | null>(null);
  const [savedReports, setSavedReports] = useState<SavedReport[]>([]);
  const [error, setError] = useState<string | null>(null);

  // Load saved reports from localStorage on initialization
  React.useEffect(() => {
    try {
      const saved = localStorage.getItem('vulnerability-reports');
      if (saved) {
        const parsed = JSON.parse(saved);
        setSavedReports(parsed);
      }
    } catch (error) {
      console.warn('Failed to load saved reports:', error);
    }
  }, []);

  // Save reports to localStorage
  const saveToStorage = useCallback((reports: SavedReport[]) => {
    try {
      localStorage.setItem('vulnerability-reports', JSON.stringify(reports));
    } catch (error) {
      console.warn('Failed to save reports to storage:', error);
    }
  }, []);

  // Generate report
  const generateReport = useCallback(async (
    analysisResult: VulnerabilityAnalysisResult,
    options: ReportOptions
  ): Promise<VulnerabilityReport> => {
    try {
      setError(null);
      setIsGenerating(true);

      const generator = createVulnerabilityReportGenerator(analysisResult, options);
      const report = await generator.generateReport();
      
      setCurrentReport(report);
      toast.success('Report generated successfully');
      
      return report;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to generate report';
      setError(errorMessage);
      toast.error(errorMessage);
      throw error;

    } finally {
      setIsGenerating(false);
    }
  }, []);

  // Export report
  const exportReport = useCallback(async (
    report: VulnerabilityReport,
    format: 'json' | 'csv' | 'html' | 'pdf' | 'markdown' = defaultFormat
  ): Promise<string> => {
    try {
      setError(null);
      setIsExporting(true);

      const options: ReportOptions = {
        format,
        includeExecutiveSummary: true,
        includeDetailedFindings: true,
        includeRecommendations: true,
        includeCharts: format === 'html' || format === 'pdf'
      };

      const generator = createVulnerabilityReportGenerator(report.rawData, options);
      const content = await generator.exportReport(report);
      
      toast.success(`Report exported as ${format.toUpperCase()}`);
      return content;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to export report';
      setError(errorMessage);
      toast.error(errorMessage);
      throw error;

    } finally {
      setIsExporting(false);
    }
  }, [defaultFormat]);

  // Quick report generation
  const generateQuickReport = useCallback(async (
    analysisResult: VulnerabilityAnalysisResult,
    format: 'json' | 'csv' | 'html' | 'pdf' | 'markdown' = defaultFormat
  ): Promise<string> => {
    try {
      setError(null);
      setIsGenerating(true);

      const content = await VulnerabilityReportGenerator.generateQuickReport(analysisResult, format);
      
      toast.success(`Quick report generated as ${format.toUpperCase()}`);
      return content;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to generate quick report';
      setError(errorMessage);
      toast.error(errorMessage);
      throw error;

    } finally {
      setIsGenerating(false);
    }
  }, [defaultFormat]);

  // Save report
  const saveReport = useCallback((
    report: VulnerabilityReport,
    name: string,
    format: string,
    content: string
  ) => {
    const savedReport: SavedReport = {
      id: `report-${Date.now()}`,
      name,
      format,
      generatedAt: report.metadata.generatedAt,
      projectName: report.metadata.projectName,
      size: new Blob([content]).size,
      content
    };

    const newReports = [savedReport, ...savedReports.slice(0, 19)]; // Keep last 20 reports
    setSavedReports(newReports);
    
    if (autoSaveReports) {
      saveToStorage(newReports);
    }

    toast.success(`Report saved as "${name}"`);
  }, [savedReports, autoSaveReports, saveToStorage]);

  // Load report
  const loadReport = useCallback((id: string): SavedReport | null => {
    const report = savedReports.find(r => r.id === id);
    return report || null;
  }, [savedReports]);

  // Delete report
  const deleteReport = useCallback((id: string) => {
    const newReports = savedReports.filter(r => r.id !== id);
    setSavedReports(newReports);
    saveToStorage(newReports);
    toast.info('Report deleted');
  }, [savedReports, saveToStorage]);

  // Clear all reports
  const clearAllReports = useCallback(() => {
    setSavedReports([]);
    localStorage.removeItem('vulnerability-reports');
    toast.info('All reports cleared');
  }, []);

  // Generate chart data
  const generateChartData = useCallback((analysisResult: VulnerabilityAnalysisResult): ChartData[] => {
    const charts: ChartData[] = [];
    const { summary, unifiedVulnerabilities } = analysisResult;

    // Severity distribution
    if (summary.totalVulnerabilities > 0) {
      charts.push({
        type: 'pie',
        title: 'Vulnerabilities by Severity',
        labels: ['Critical', 'High', 'Medium', 'Low'],
        datasets: [{
          label: 'Count',
          data: [summary.criticalCount, summary.highCount, summary.mediumCount, summary.lowCount],
          backgroundColor: ['#dc2626', '#ea580c', '#d97706', '#65a30d']
        }]
      });
    }

    // Ecosystem distribution
    const ecosystemCounts = new Map<string, number>();
    unifiedVulnerabilities.forEach(vuln => {
      const count = ecosystemCounts.get(vuln.ecosystem) || 0;
      ecosystemCounts.set(vuln.ecosystem, count + 1);
    });

    if (ecosystemCounts.size > 0) {
      charts.push({
        type: 'bar',
        title: 'Vulnerabilities by Ecosystem',
        labels: Array.from(ecosystemCounts.keys()),
        datasets: [{
          label: 'Vulnerabilities',
          data: Array.from(ecosystemCounts.values()),
          backgroundColor: ['#3b82f6']
        }]
      });
    }

    // Fixable vs Non-fixable
    if (summary.totalVulnerabilities > 0) {
      charts.push({
        type: 'doughnut',
        title: 'Remediation Status',
        labels: ['Fixable', 'Manual Review Required'],
        datasets: [{
          label: 'Count',
          data: [summary.fixableCount, summary.totalVulnerabilities - summary.fixableCount],
          backgroundColor: ['#10b981', '#f59e0b']
        }]
      });
    }

    // CVSS Score distribution
    const cvssRanges = { 'Low (0-3.9)': 0, 'Medium (4.0-6.9)': 0, 'High (7.0-8.9)': 0, 'Critical (9.0-10)': 0 };
    unifiedVulnerabilities.forEach(vuln => {
      if (vuln.cvssScore) {
        if (vuln.cvssScore < 4.0) cvssRanges['Low (0-3.9)']++;
        else if (vuln.cvssScore < 7.0) cvssRanges['Medium (4.0-6.9)']++;
        else if (vuln.cvssScore < 9.0) cvssRanges['High (7.0-8.9)']++;
        else cvssRanges['Critical (9.0-10)']++;
      }
    });

    const cvssTotal = Object.values(cvssRanges).reduce((sum, count) => sum + count, 0);
    if (cvssTotal > 0) {
      charts.push({
        type: 'bar',
        title: 'CVSS Score Distribution',
        labels: Object.keys(cvssRanges),
        datasets: [{
          label: 'Count',
          data: Object.values(cvssRanges),
          backgroundColor: ['#65a30d', '#d97706', '#ea580c', '#dc2626']
        }]
      });
    }

    return charts;
  }, []);

  // Get report templates
  const getReportTemplates = useCallback(() => {
    return [
      {
        name: 'Executive Summary',
        description: 'High-level overview for management',
        options: {
          includeExecutiveSummary: true,
          includeDetailedFindings: false,
          includeRecommendations: true,
          includeCharts: true,
          severityFilter: ['critical', 'high'] as ('critical' | 'high' | 'medium' | 'low')[]
        }
      },
      {
        name: 'Technical Report',
        description: 'Detailed technical findings for developers',
        options: {
          includeExecutiveSummary: true,
          includeDetailedFindings: true,
          includeRecommendations: true,
          includeCharts: false,
          sortBy: 'severity' as 'severity' | 'package' | 'cvss' | 'publishedDate',
          sortOrder: 'desc' as 'asc' | 'desc'
        }
      },
      {
        name: 'Compliance Report',
        description: 'Comprehensive report for compliance requirements',
        options: {
          includeExecutiveSummary: true,
          includeDetailedFindings: true,
          includeRecommendations: true,
          includeCharts: true,
          groupBy: 'severity' as 'severity' | 'package' | 'ecosystem' | 'source'
        }
      },
      {
        name: 'Critical Issues Only',
        description: 'Focus on critical and high severity vulnerabilities',
        options: {
          includeExecutiveSummary: false,
          includeDetailedFindings: true,
          includeRecommendations: true,
          includeCharts: false,
          severityFilter: ['critical', 'high'] as ('critical' | 'high' | 'medium' | 'low')[],
          sortBy: 'cvss' as 'severity' | 'package' | 'cvss' | 'publishedDate',
          sortOrder: 'desc' as 'asc' | 'desc'
        }
      }
    ];
  }, []);

  // Download report
  const downloadReport = useCallback((content: string, filename: string, format: string) => {
    try {
      let mimeType = 'text/plain';
      let fileExtension = '.txt';

      switch (format.toLowerCase()) {
        case 'json':
          mimeType = 'application/json';
          fileExtension = '.json';
          break;
        case 'csv':
          mimeType = 'text/csv';
          fileExtension = '.csv';
          break;
        case 'html':
          mimeType = 'text/html';
          fileExtension = '.html';
          break;
        case 'pdf':
          mimeType = 'application/pdf';
          fileExtension = '.pdf';
          break;
        case 'markdown':
          mimeType = 'text/markdown';
          fileExtension = '.md';
          break;
      }

      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = filename.endsWith(fileExtension) ? filename : filename + fileExtension;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      URL.revokeObjectURL(url);
      toast.success('Report downloaded successfully');

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to download report';
      toast.error(errorMessage);
    }
  }, []);

  // Format file size
  const formatFileSize = useCallback((bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }, []);

  // Validate report options
  const validateReportOptions = useCallback((options: ReportOptions): { valid: boolean; errors: string[] } => {
    const errors: string[] = [];

    if (!options.format) {
      errors.push('Report format is required');
    }

    if (!['json', 'csv', 'html', 'pdf', 'markdown'].includes(options.format)) {
      errors.push('Invalid report format');
    }

    if (options.severityFilter && options.severityFilter.length === 0) {
      errors.push('Severity filter cannot be empty if specified');
    }

    if (options.severityFilter) {
      const validSeverities = ['critical', 'high', 'medium', 'low'];
      const invalidSeverities = options.severityFilter.filter(s => !validSeverities.includes(s));
      if (invalidSeverities.length > 0) {
        errors.push(`Invalid severity levels: ${invalidSeverities.join(', ')}`);
      }
    }

    if (options.sortBy && !['severity', 'package', 'cvss', 'publishedDate'].includes(options.sortBy)) {
      errors.push('Invalid sort field');
    }

    if (options.sortOrder && !['asc', 'desc'].includes(options.sortOrder)) {
      errors.push('Invalid sort order');
    }

    if (options.groupBy && !['severity', 'package', 'ecosystem', 'source'].includes(options.groupBy)) {
      errors.push('Invalid group by field');
    }

    return { valid: errors.length === 0, errors };
  }, []);

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    // Report generation
    isGenerating,
    currentReport,
    generateReport,
    
    // Report export
    isExporting,
    exportReport,
    
    // Quick report generation
    generateQuickReport,
    
    // Report management
    savedReports,
    saveReport,
    loadReport,
    deleteReport,
    clearAllReports,
    
    // Chart data generation
    generateChartData,
    
    // Report templates
    getReportTemplates,
    
    // Download utilities
    downloadReport,
    
    // Utilities
    formatFileSize,
    validateReportOptions,
    error,
    clearError
  };
};

// Add React import for useEffect
import React from 'react';