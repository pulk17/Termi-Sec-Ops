import { VulnerabilityAnalysisResult, UnifiedVulnerability } from './vulnerability-analysis';
import { ProjectInfo } from './project-analyzer';
import jsPDF from 'jspdf';
import 'jspdf-autotable';

export interface ReportOptions {
  format: 'json' | 'csv' | 'html' | 'pdf' | 'markdown';
  includeExecutiveSummary: boolean;
  includeDetailedFindings: boolean;
  includeRecommendations: boolean;
  includeCharts: boolean;
  severityFilter?: ('critical' | 'high' | 'medium' | 'low')[];
  groupBy?: 'severity' | 'package' | 'ecosystem' | 'source';
  sortBy?: 'severity' | 'package' | 'cvss' | 'publishedDate';
  sortOrder?: 'asc' | 'desc';
  customTemplate?: string;
}

export interface ReportSection {
  title: string;
  content: string;
  type: 'text' | 'table' | 'chart' | 'list';
  data?: any;
}

export interface VulnerabilityReport {
  metadata: {
    title: string;
    generatedAt: Date;
    projectName: string;
    reportId: string;
    version: string;
  };
  executiveSummary: {
    totalVulnerabilities: number;
    riskLevel: string;
    securityScore: number;
    keyFindings: string[];
    recommendations: string[];
  };
  sections: ReportSection[];
  rawData: VulnerabilityAnalysisResult;
}

export interface ChartData {
  type: 'pie' | 'bar' | 'line' | 'doughnut';
  title: string;
  labels: string[];
  datasets: Array<{
    label: string;
    data: number[];
    backgroundColor?: string[];
    borderColor?: string[];
  }>;
}

export class VulnerabilityReportGenerator {
  private analysisResult: VulnerabilityAnalysisResult;
  private options: ReportOptions;

  constructor(analysisResult: VulnerabilityAnalysisResult, options: ReportOptions) {
    this.analysisResult = analysisResult;
    this.options = options;
  }

  async generateReport(): Promise<VulnerabilityReport> {
    const reportId = `vuln-report-${Date.now()}`;
    const projectName = 'Security Assessment Project';

    const report: VulnerabilityReport = {
      metadata: {
        title: `Vulnerability Assessment Report - ${projectName}`,
        generatedAt: new Date(),
        projectName,
        reportId,
        version: '1.0.0'
      },
      executiveSummary: this.generateExecutiveSummary(),
      sections: [],
      rawData: this.analysisResult
    };

    // Generate sections based on options
    if (this.options.includeExecutiveSummary) {
      report.sections.push(this.generateOverviewSection());
    }

    if (this.options.includeCharts) {
      report.sections.push(this.generateChartsSection());
    }

    if (this.options.includeDetailedFindings) {
      report.sections.push(this.generateFindingsSection());
    }

    if (this.options.includeRecommendations) {
      report.sections.push(this.generateRecommendationsSection());
    }

    // Add additional sections
    report.sections.push(this.generateProjectInfoSection());
    report.sections.push(this.generateScanDetailsSection());

    return report;
  }

  async exportReport(report: VulnerabilityReport): Promise<string> {
    switch (this.options.format) {
      case 'json':
        return this.exportAsJSON(report);
      case 'csv':
        return this.exportAsCSV(report);
      case 'html':
        return this.exportAsHTML(report);
      case 'pdf':
        return await this.exportAsPDF(report);
      case 'markdown':
        return this.exportAsMarkdown(report);
      default:
        throw new Error(`Unsupported format: ${this.options.format}`);
    }
  }

  private generateExecutiveSummary(): VulnerabilityReport['executiveSummary'] {
    const { summary, recommendations } = this.analysisResult;
    
    const keyFindings: string[] = [];
    
    if (summary.criticalCount > 0) {
      keyFindings.push(`${summary.criticalCount} critical vulnerabilities require immediate attention`);
    }
    
    if (summary.highCount > 0) {
      keyFindings.push(`${summary.highCount} high-severity vulnerabilities found`);
    }
    
    if (summary.fixableCount > 0) {
      const percentage = Math.round((summary.fixableCount / summary.totalVulnerabilities) * 100);
      keyFindings.push(`${percentage}% of vulnerabilities can be fixed by updating dependencies`);
    }

    if (summary.securityScore < 70) {
      keyFindings.push(`Security score of ${summary.securityScore}/100 indicates significant security concerns`);
    }

    return {
      totalVulnerabilities: summary.totalVulnerabilities,
      riskLevel: summary.riskLevel,
      securityScore: summary.securityScore,
      keyFindings,
      recommendations: recommendations.slice(0, 5) // Top 5 recommendations
    };
  }

  private generateOverviewSection(): ReportSection {
    const { summary } = this.analysisResult;
    
    const content = `
This report provides a comprehensive analysis of security vulnerabilities found in the project dependencies.

**Risk Assessment:**
- Overall Risk Level: ${summary.riskLevel.toUpperCase()}
- Security Score: ${summary.securityScore}/100
- Total Vulnerabilities: ${summary.totalVulnerabilities}

**Severity Breakdown:**
- Critical: ${summary.criticalCount}
- High: ${summary.highCount}
- Medium: ${summary.mediumCount}
- Low: ${summary.lowCount}

**Remediation Status:**
- Fixable: ${summary.fixableCount} (${Math.round((summary.fixableCount / Math.max(summary.totalVulnerabilities, 1)) * 100)}%)
- Requires Manual Review: ${summary.totalVulnerabilities - summary.fixableCount}
    `;

    return {
      title: 'Executive Summary',
      content: content.trim(),
      type: 'text'
    };
  }

  private generateChartsSection(): ReportSection {
    const charts: ChartData[] = [];

    // Severity distribution pie chart
    const { summary } = this.analysisResult;
    if (summary.totalVulnerabilities > 0) {
      charts.push({
        type: 'pie',
        title: 'Vulnerabilities by Severity',
        labels: ['Critical', 'High', 'Medium', 'Low'],
        datasets: [{
          label: 'Count',
          data: [summary.criticalCount, summary.highCount, summary.mediumCount, summary.lowCount],
          backgroundColor: ['#dc2626', '#ea580c', '#d97706', '#65a30d']
        }]
      });
    }

    // Vulnerabilities by ecosystem
    const ecosystemCounts = new Map<string, number>();
    this.getFilteredVulnerabilities().forEach(vuln => {
      const count = ecosystemCounts.get(vuln.ecosystem) || 0;
      ecosystemCounts.set(vuln.ecosystem, count + 1);
    });

    if (ecosystemCounts.size > 0) {
      charts.push({
        type: 'bar',
        title: 'Vulnerabilities by Ecosystem',
        labels: Array.from(ecosystemCounts.keys()),
        datasets: [{
          label: 'Vulnerabilities',
          data: Array.from(ecosystemCounts.values()),
          backgroundColor: ['#3b82f6']
        }]
      });
    }

    // Fixable vs Non-fixable
    if (summary.totalVulnerabilities > 0) {
      charts.push({
        type: 'doughnut',
        title: 'Remediation Status',
        labels: ['Fixable', 'Manual Review Required'],
        datasets: [{
          label: 'Count',
          data: [summary.fixableCount, summary.totalVulnerabilities - summary.fixableCount],
          backgroundColor: ['#10b981', '#f59e0b']
        }]
      });
    }

    return {
      title: 'Vulnerability Analysis Charts',
      content: 'Visual representation of vulnerability data',
      type: 'chart',
      data: charts
    };
  }

  private generateFindingsSection(): ReportSection {
    const vulnerabilities = this.getFilteredVulnerabilities();
    const sortedVulns = this.sortVulnerabilities(vulnerabilities);
    
    let content = '## Detailed Vulnerability Findings\n\n';
    
    if (this.options.groupBy) {
      const grouped = this.groupVulnerabilities(sortedVulns);
      
      Object.entries(grouped).forEach(([group, vulns]) => {
        content += `### ${group}\n\n`;
        vulns.forEach(vuln => {
          content += this.formatVulnerabilityDetail(vuln) + '\n\n';
        });
      });
    } else {
      sortedVulns.forEach(vuln => {
        content += this.formatVulnerabilityDetail(vuln) + '\n\n';
      });
    }

    return {
      title: 'Detailed Findings',
      content,
      type: 'text',
      data: sortedVulns
    };
  }

  private generateRecommendationsSection(): ReportSection {
    const { recommendations } = this.analysisResult;
    
    let content = '## Security Recommendations\n\n';
    
    recommendations.forEach((rec, index) => {
      content += `${index + 1}. ${rec}\n`;
    });

    // Add additional recommendations based on analysis
    content += '\n### Additional Recommendations:\n\n';
    
    const { summary } = this.analysisResult;
    
    if (summary.criticalCount > 0) {
      content += '- **Immediate Action Required**: Address all critical vulnerabilities within 24-48 hours\n';
    }
    
    if (summary.highCount > 0) {
      content += '- **High Priority**: Schedule fixes for high-severity vulnerabilities within 1 week\n';
    }
    
    if (summary.securityScore < 50) {
      content += '- **Security Review**: Conduct a comprehensive security review of the application\n';
    }
    
    content += '- **Continuous Monitoring**: Implement automated vulnerability scanning in CI/CD pipeline\n';
    content += '- **Dependency Management**: Regularly update dependencies and monitor for new vulnerabilities\n';
    content += '- **Security Training**: Ensure development team is trained on secure coding practices\n';

    return {
      title: 'Recommendations',
      content,
      type: 'text'
    };
  }

  private generateProjectInfoSection(): ReportSection {
    const { projectInfo } = this.analysisResult;
    
    let content = `## Project Information\n\n`;
    content += `- **Language**: ${projectInfo.language}\n`;
    content += `- **Framework**: ${projectInfo.framework || 'N/A'}\n`;
    content += `- **Package Manager**: ${projectInfo.packageManager || 'N/A'}\n`;
    content += `- **Dependencies**: ${projectInfo.dependencies.length} production, ${projectInfo.devDependencies.length} development\n`;
    content += `- **Build Tool**: ${projectInfo.buildTool || 'None detected'}\n`;
    content += `- **Has Dockerfile**: ${projectInfo.hasDockerfile ? 'Yes' : 'No'}\n`;
    content += `- **Has CI/CD**: ${projectInfo.hasCI ? 'Yes' : 'No'}\n`;
    if (projectInfo.ciPlatform) {
      content += `- **CI Platform**: ${projectInfo.ciPlatform}\n`;
    }

    return {
      title: 'Project Information',
      content,
      type: 'text'
    };
  }

  private generateScanDetailsSection(): ReportSection {
    const { sources, scanDuration, timestamp } = this.analysisResult;
    
    let content = `## Scan Details\n\n`;
    content += `- **Scan Date**: ${timestamp.toISOString()}\n`;
    content += `- **Scan Duration**: ${Math.round(scanDuration / 1000)} seconds\n`;
    content += `- **Sources Used**: ${sources.length}\n\n`;

    content += `### Vulnerability Sources:\n\n`;
    sources.forEach(source => {
      content += `#### ${source.name.toUpperCase()}\n`;
      content += `- **Status**: ${source.error ? 'Failed' : 'Success'}\n`;
      content += `- **Vulnerabilities Found**: ${source.summary.total}\n`;
      content += `- **Scan Duration**: ${Math.round(source.scanDuration / 1000)} seconds\n`;
      
      if (source.error) {
        content += `- **Error**: ${source.error}\n`;
      }
      
      content += `- **Severity Breakdown**: Critical: ${source.summary.critical}, High: ${source.summary.high}, Medium: ${source.summary.medium}, Low: ${source.summary.low}\n\n`;
    });

    return {
      title: 'Scan Details',
      content,
      type: 'text'
    };
  }

  private getFilteredVulnerabilities(): UnifiedVulnerability[] {
    let vulnerabilities = this.analysisResult.unifiedVulnerabilities;

    if (this.options.severityFilter && this.options.severityFilter.length > 0) {
      vulnerabilities = vulnerabilities.filter(vuln => 
        this.options.severityFilter!.includes(vuln.severity)
      );
    }

    return vulnerabilities;
  }

  private sortVulnerabilities(vulnerabilities: UnifiedVulnerability[]): UnifiedVulnerability[] {
    const sortBy = this.options.sortBy || 'severity';
    const sortOrder = this.options.sortOrder || 'desc';

    return vulnerabilities.sort((a, b) => {
      let comparison = 0;

      switch (sortBy) {
        case 'severity':
          const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
          comparison = severityOrder[a.severity] - severityOrder[b.severity];
          break;
        case 'package':
          comparison = a.packageName.localeCompare(b.packageName);
          break;
        case 'cvss':
          comparison = (a.cvssScore || 0) - (b.cvssScore || 0);
          break;
        case 'publishedDate':
          const aDate = a.publishedDate?.getTime() || 0;
          const bDate = b.publishedDate?.getTime() || 0;
          comparison = aDate - bDate;
          break;
      }

      return sortOrder === 'asc' ? comparison : -comparison;
    });
  }

  private groupVulnerabilities(vulnerabilities: UnifiedVulnerability[]): Record<string, UnifiedVulnerability[]> {
    const grouped: Record<string, UnifiedVulnerability[]> = {};

    vulnerabilities.forEach(vuln => {
      let key: string;

      switch (this.options.groupBy) {
        case 'severity':
          key = vuln.severity.charAt(0).toUpperCase() + vuln.severity.slice(1);
          break;
        case 'package':
          key = vuln.packageName;
          break;
        case 'ecosystem':
          key = vuln.ecosystem;
          break;
        case 'source':
          key = vuln.sources.map(s => s.name).join(', ');
          break;
        default:
          key = 'All Vulnerabilities';
      }

      if (!grouped[key]) {
        grouped[key] = [];
      }
      grouped[key].push(vuln);
    });

    return grouped;
  }

  private formatVulnerabilityDetail(vuln: UnifiedVulnerability): string {
    let detail = `#### ${vuln.title}\n\n`;
    detail += `- **Package**: ${vuln.packageName}@${vuln.packageVersion}\n`;
    detail += `- **Severity**: ${vuln.severity.toUpperCase()}`;
    
    if (vuln.cvssScore) {
      detail += ` (CVSS: ${vuln.cvssScore})`;
    }
    detail += '\n';
    
    detail += `- **Ecosystem**: ${vuln.ecosystem}\n`;
    detail += `- **Vulnerability ID**: ${vuln.id}\n`;
    
    if (vuln.cwe && vuln.cwe.length > 0) {
      detail += `- **CWE**: ${vuln.cwe.join(', ')}\n`;
    }
    
    detail += `- **Fix Available**: ${vuln.isUpgradable || vuln.isPatchable ? 'Yes' : 'No'}`;
    
    if (vuln.fixedIn) {
      detail += ` (Fixed in: ${vuln.fixedIn})`;
    }
    detail += '\n';
    
    if (vuln.publishedDate) {
      detail += `- **Published**: ${vuln.publishedDate.toDateString()}\n`;
    }
    
    detail += `- **Sources**: ${vuln.sources.map(s => s.name).join(', ')}\n`;
    
    if (vuln.description) {
      detail += `\n**Description**: ${vuln.description}\n`;
    }
    
    if (vuln.references.length > 0) {
      detail += `\n**References**:\n`;
      vuln.references.slice(0, 3).forEach(ref => {
        detail += `- ${ref}\n`;
      });
    }

    return detail;
  }

  // Export methods
  private exportAsJSON(report: VulnerabilityReport): string {
    return JSON.stringify(report, null, 2);
  }

  private exportAsCSV(report: VulnerabilityReport): string {
    const vulnerabilities = this.getFilteredVulnerabilities();
    const headers = [
      'Package',
      'Version',
      'Ecosystem',
      'Vulnerability ID',
      'Title',
      'Severity',
      'CVSS Score',
      'CWE',
      'Fix Available',
      'Fixed In',
      'Published Date',
      'Sources',
      'References'
    ];

    const rows = vulnerabilities.map(vuln => [
      vuln.packageName,
      vuln.packageVersion,
      vuln.ecosystem,
      vuln.id,
      `"${vuln.title.replace(/"/g, '""')}"`,
      vuln.severity,
      vuln.cvssScore?.toString() || '',
      vuln.cwe?.join(';') || '',
      vuln.isUpgradable || vuln.isPatchable ? 'Yes' : 'No',
      vuln.fixedIn || '',
      vuln.publishedDate?.toISOString() || '',
      vuln.sources.map(s => s.name).join(';'),
      vuln.references.slice(0, 3).join(';')
    ]);

    return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
  }

  private exportAsHTML(report: VulnerabilityReport): string {
    const { metadata, executiveSummary, sections } = report;
    
    let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${metadata.title}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        .header { border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin-bottom: 30px; }
        .severity-critical { color: #dc2626; font-weight: bold; }
        .severity-high { color: #ea580c; font-weight: bold; }
        .severity-medium { color: #d97706; font-weight: bold; }
        .severity-low { color: #65a30d; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background-color: #f2f2f2; }
        .metric { display: inline-block; margin: 10px 20px 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${metadata.title}</h1>
        <p><strong>Generated:</strong> ${metadata.generatedAt.toLocaleString()}</p>
        <p><strong>Report ID:</strong> ${metadata.reportId}</p>
    </div>`;

    // Executive Summary
    html += `
    <div class="section">
        <h2>Executive Summary</h2>
        <div class="metric">
            <strong>Risk Level:</strong> <span class="severity-${executiveSummary.riskLevel}">${executiveSummary.riskLevel.toUpperCase()}</span>
        </div>
        <div class="metric">
            <strong>Security Score:</strong> ${executiveSummary.securityScore}/100
        </div>
        <div class="metric">
            <strong>Total Vulnerabilities:</strong> ${executiveSummary.totalVulnerabilities}
        </div>
        
        <h3>Key Findings</h3>
        <ul>
            ${executiveSummary.keyFindings.map(finding => `<li>${finding}</li>`).join('')}
        </ul>
        
        <h3>Top Recommendations</h3>
        <ul>
            ${executiveSummary.recommendations.map(rec => `<li>${rec}</li>`).join('')}
        </ul>
    </div>`;

    // Add sections
    sections.forEach(section => {
      html += `<div class="section">`;
      html += `<h2>${section.title}</h2>`;
      
      if (section.type === 'text') {
        html += `<div>${section.content.replace(/\n/g, '<br>')}</div>`;
      } else if (section.type === 'table' && section.data) {
        // Add table rendering logic here
      }
      
      html += `</div>`;
    });

    html += `</body></html>`;
    return html;
  }

  private async exportAsPDF(report: VulnerabilityReport): Promise<string> {
    const doc = new jsPDF();
    const { metadata, executiveSummary } = report;
    
    // Title page
    doc.setFontSize(20);
    doc.text(metadata.title, 20, 30);
    
    doc.setFontSize(12);
    doc.text(`Generated: ${metadata.generatedAt.toLocaleString()}`, 20, 50);
    doc.text(`Report ID: ${metadata.reportId}`, 20, 60);
    
    // Executive Summary
    doc.setFontSize(16);
    doc.text('Executive Summary', 20, 80);
    
    doc.setFontSize(12);
    let yPos = 100;
    
    doc.text(`Risk Level: ${executiveSummary.riskLevel.toUpperCase()}`, 20, yPos);
    yPos += 10;
    doc.text(`Security Score: ${executiveSummary.securityScore}/100`, 20, yPos);
    yPos += 10;
    doc.text(`Total Vulnerabilities: ${executiveSummary.totalVulnerabilities}`, 20, yPos);
    yPos += 20;
    
    // Key Findings
    doc.setFontSize(14);
    doc.text('Key Findings:', 20, yPos);
    yPos += 10;
    
    doc.setFontSize(10);
    executiveSummary.keyFindings.forEach(finding => {
      const lines = doc.splitTextToSize(`â€¢ ${finding}`, 170);
      doc.text(lines, 25, yPos);
      yPos += lines.length * 5 + 5;
    });
    
    // Add vulnerability table
    const vulnerabilities = this.getFilteredVulnerabilities().slice(0, 50); // Limit for PDF
    if (vulnerabilities.length > 0) {
      doc.addPage();
      doc.setFontSize(16);
      doc.text('Vulnerability Details', 20, 30);
      
      const tableData = vulnerabilities.map(vuln => [
        vuln.packageName,
        vuln.severity,
        vuln.cvssScore?.toString() || 'N/A',
        vuln.isUpgradable || vuln.isPatchable ? 'Yes' : 'No'
      ]);
      
      (doc as any).autoTable({
        head: [['Package', 'Severity', 'CVSS', 'Fixable']],
        body: tableData,
        startY: 40,
        styles: { fontSize: 8 },
        headStyles: { fillColor: [66, 139, 202] }
      });
    }
    
    return doc.output('datauristring');
  }

  private exportAsMarkdown(report: VulnerabilityReport): string {
    const { metadata, executiveSummary, sections } = report;
    
    let markdown = `# ${metadata.title}\n\n`;
    markdown += `**Generated:** ${metadata.generatedAt.toLocaleString()}\n`;
    markdown += `**Report ID:** ${metadata.reportId}\n\n`;
    
    // Executive Summary
    markdown += `## Executive Summary\n\n`;
    markdown += `- **Risk Level:** ${executiveSummary.riskLevel.toUpperCase()}\n`;
    markdown += `- **Security Score:** ${executiveSummary.securityScore}/100\n`;
    markdown += `- **Total Vulnerabilities:** ${executiveSummary.totalVulnerabilities}\n\n`;
    
    markdown += `### Key Findings\n\n`;
    executiveSummary.keyFindings.forEach(finding => {
      markdown += `- ${finding}\n`;
    });
    
    markdown += `\n### Top Recommendations\n\n`;
    executiveSummary.recommendations.forEach(rec => {
      markdown += `- ${rec}\n`;
    });
    markdown += '\n';
    
    // Add sections
    sections.forEach(section => {
      markdown += `${section.content}\n\n`;
    });
    
    return markdown;
  }

  // Static utility methods
  static async generateQuickReport(
    analysisResult: VulnerabilityAnalysisResult,
    format: 'json' | 'csv' | 'html' | 'pdf' | 'markdown' = 'json'
  ): Promise<string> {
    const options: ReportOptions = {
      format,
      includeExecutiveSummary: true,
      includeDetailedFindings: true,
      includeRecommendations: true,
      includeCharts: format === 'html' || format === 'pdf',
      sortBy: 'severity',
      sortOrder: 'desc'
    };

    const generator = new VulnerabilityReportGenerator(analysisResult, options);
    const report = await generator.generateReport();
    return await generator.exportReport(report);
  }

  static getSeverityColor(severity: string): string {
    const colors = {
      critical: '#dc2626',
      high: '#ea580c',
      medium: '#d97706',
      low: '#65a30d'
    };
    return colors[severity as keyof typeof colors] || '#6b7280';
  }

  static formatCVSSScore(score?: number): string {
    if (!score) return 'N/A';
    
    let rating = 'Unknown';
    if (score >= 9.0) rating = 'Critical';
    else if (score >= 7.0) rating = 'High';
    else if (score >= 4.0) rating = 'Medium';
    else rating = 'Low';
    
    return `${score.toFixed(1)} (${rating})`;
  }
}

// Create report generator
export const createVulnerabilityReportGenerator = (
  analysisResult: VulnerabilityAnalysisResult,
  options: ReportOptions
): VulnerabilityReportGenerator => {
  return new VulnerabilityReportGenerator(analysisResult, options);
};