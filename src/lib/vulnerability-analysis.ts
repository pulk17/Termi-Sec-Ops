import { OSVClient, OSVVulnerability, OSVQueryRequest, osvClient } from './osv';
import { NpmAuditClient, NpmAuditResult, npmAuditClient } from './npm-audit';
import { SnykClient, SnykTestResult } from './snyk';
import { ProjectInfo, Dependency } from './project-analyzer';
// Removed unused toast import

export interface VulnerabilityAnalysisOptions {
  enableOSV: boolean;
  enableNpmAudit: boolean;
  enableSnyk: boolean;
  snykClient?: SnykClient;
  snykOrgId?: string;
  severityThreshold?: 'low' | 'medium' | 'high' | 'critical';
  includeDevDependencies: boolean;
  maxConcurrentRequests: number;
}

export interface VulnerabilitySource {
  name: 'osv' | 'npm-audit' | 'snyk';
  enabled: boolean;
  vulnerabilities: any[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  scanDuration: number;
  error?: string;
}

export interface UnifiedVulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  packageName: string;
  packageVersion: string;
  ecosystem: string;
  cvssScore?: number;
  cwe?: string[];
  references: string[];
  fixedIn?: string;
  isUpgradable: boolean;
  isPatchable: boolean;
  publishedDate?: Date;
  modifiedDate?: Date;
  sources: Array<{
    name: 'osv' | 'npm-audit' | 'snyk';
    id: string;
    url?: string;
  }>;
}

export interface VulnerabilityAnalysisResult {
  projectInfo: ProjectInfo;
  sources: VulnerabilitySource[];
  unifiedVulnerabilities: UnifiedVulnerability[];
  summary: {
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
    fixableCount: number;
    securityScore: number;
    riskLevel: 'low' | 'medium' | 'high' | 'critical';
    coverageScore: number; // How many dependencies were successfully scanned
  };
  scanDuration: number;
  timestamp: Date;
  recommendations: string[];
}

export interface AnalysisProgress {
  stage: 'initializing' | 'scanning-osv' | 'scanning-npm' | 'scanning-snyk' | 'unifying' | 'completed' | 'failed';
  progress: number; // 0-100
  message: string;
  currentSource?: string;
  scannedPackages: number;
  totalPackages: number;
}

export class VulnerabilityAnalysisService {
  private osvClient: OSVClient;
  private npmAuditClient: NpmAuditClient;
  private progressCallback?: (progress: AnalysisProgress) => void;

  constructor(progressCallback?: (progress: AnalysisProgress) => void) {
    this.osvClient = osvClient;
    this.npmAuditClient = npmAuditClient;
    this.progressCallback = progressCallback;
  }

  async analyzeProject(
    projectInfo: ProjectInfo,
    options: VulnerabilityAnalysisOptions
  ): Promise<VulnerabilityAnalysisResult> {
    const startTime = Date.now();
    const sources: VulnerabilitySource[] = [];
    const recommendations: string[] = [];

    try {
      this.updateProgress({
        stage: 'initializing',
        progress: 5,
        message: 'Initializing vulnerability analysis...',
        scannedPackages: 0,
        totalPackages: 0
      });

      // Get all dependencies to scan
      const dependencies = options.includeDevDependencies 
        ? [...projectInfo.dependencies, ...projectInfo.devDependencies]
        : projectInfo.dependencies;

      if (dependencies.length === 0) {
        throw new Error('No dependencies found to analyze');
      }

      this.updateProgress({
        stage: 'initializing',
        progress: 10,
        message: `Found ${dependencies.length} dependencies to analyze`,
        scannedPackages: 0,
        totalPackages: dependencies.length
      });

      // Scan with OSV
      if (options.enableOSV) {
        const osvSource = await this.scanWithOSV(dependencies, options);
        sources.push(osvSource);
      }

      // Scan with npm audit (for Node.js projects)
      if (options.enableNpmAudit && projectInfo.packageManager === 'npm') {
        const npmSource = await this.scanWithNpmAudit(dependencies, options);
        sources.push(npmSource);
      }

      // Scan with Snyk
      if (options.enableSnyk && options.snykClient) {
        const snykSource = await this.scanWithSnyk(dependencies, options);
        sources.push(snykSource);
      }

      // Unify results
      this.updateProgress({
        stage: 'unifying',
        progress: 90,
        message: 'Unifying vulnerability data...',
        scannedPackages: dependencies.length,
        totalPackages: dependencies.length
      });

      const unifiedVulnerabilities = this.unifyVulnerabilities(sources);
      const summary = this.calculateSummary(unifiedVulnerabilities, dependencies.length);
      const scanDuration = Date.now() - startTime;

      // Generate recommendations
      recommendations.push(...this.generateRecommendations(summary, sources, projectInfo));

      this.updateProgress({
        stage: 'completed',
        progress: 100,
        message: `Analysis completed - found ${summary.totalVulnerabilities} vulnerabilities`,
        scannedPackages: dependencies.length,
        totalPackages: dependencies.length
      });

      return {
        projectInfo,
        sources,
        unifiedVulnerabilities,
        summary,
        scanDuration,
        timestamp: new Date(),
        recommendations
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Analysis failed';
      
      this.updateProgress({
        stage: 'failed',
        progress: 0,
        message: errorMessage,
        scannedPackages: 0,
        totalPackages: 0
      });

      throw error;
    }
  }

  private async scanWithOSV(
    dependencies: Dependency[],
    options: VulnerabilityAnalysisOptions
  ): Promise<VulnerabilitySource> {
    const startTime = Date.now();
    
    try {
      this.updateProgress({
        stage: 'scanning-osv',
        progress: 20,
        message: 'Scanning with OSV database...',
        currentSource: 'OSV',
        scannedPackages: 0,
        totalPackages: dependencies.length
      });

      // Prepare queries for OSV
      const queries: OSVQueryRequest[] = dependencies.map(dep => ({
        package: {
          name: dep.name,
          ecosystem: OSVClient.mapEcosystemName(dep.ecosystem)
        },
        version: dep.version
      }));

      // Batch query OSV
      const results = await this.osvClient.queryPackages(queries);
      const vulnerabilities: OSVVulnerability[] = [];

      results.forEach(result => {
        if (result.vulns) {
          vulnerabilities.push(...result.vulns);
        }
      });

      // Calculate summary
      const summary = {
        total: vulnerabilities.length,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      };

      vulnerabilities.forEach(vuln => {
        const score = OSVClient.extractSeverityScore(vuln);
        const severity = OSVClient.categorizeSeverity(score);
        summary[severity]++;
      });

      return {
        name: 'osv',
        enabled: true,
        vulnerabilities,
        summary,
        scanDuration: Date.now() - startTime
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'OSV scan failed';
      console.error('OSV scan error:', error);

      return {
        name: 'osv',
        enabled: true,
        vulnerabilities: [],
        summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
        scanDuration: Date.now() - startTime,
        error: errorMessage
      };
    }
  }

  private async scanWithNpmAudit(
    dependencies: Dependency[],
    options: VulnerabilityAnalysisOptions
  ): Promise<VulnerabilitySource> {
    const startTime = Date.now();
    
    try {
      this.updateProgress({
        stage: 'scanning-npm',
        progress: 50,
        message: 'Scanning with npm audit...',
        currentSource: 'npm-audit',
        scannedPackages: 0,
        totalPackages: dependencies.length
      });

      // Filter npm dependencies
      const npmDependencies = dependencies.filter(dep => dep.ecosystem === 'npm');
      const dependencyMap: Record<string, string> = {};
      
      npmDependencies.forEach(dep => {
        dependencyMap[dep.name] = dep.version;
      });

      const auditResult = await this.npmAuditClient.auditPackages(dependencyMap);
      const vulnerabilities = Object.values(auditResult.vulnerabilities);

      // Map npm audit severity to our standard
      const summary = {
        total: auditResult.metadata.vulnerabilities.total,
        critical: auditResult.metadata.vulnerabilities.critical,
        high: auditResult.metadata.vulnerabilities.high,
        medium: auditResult.metadata.vulnerabilities.moderate,
        low: auditResult.metadata.vulnerabilities.low
      };

      return {
        name: 'npm-audit',
        enabled: true,
        vulnerabilities,
        summary,
        scanDuration: Date.now() - startTime
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'npm audit scan failed';
      console.error('npm audit scan error:', error);

      return {
        name: 'npm-audit',
        enabled: true,
        vulnerabilities: [],
        summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
        scanDuration: Date.now() - startTime,
        error: errorMessage
      };
    }
  }

  private async scanWithSnyk(
    dependencies: Dependency[],
    options: VulnerabilityAnalysisOptions
  ): Promise<VulnerabilitySource> {
    const startTime = Date.now();
    
    try {
      this.updateProgress({
        stage: 'scanning-snyk',
        progress: 70,
        message: 'Scanning with Snyk...',
        currentSource: 'Snyk',
        scannedPackages: 0,
        totalPackages: dependencies.length
      });

      if (!options.snykClient) {
        throw new Error('Snyk client not provided');
      }

      // Group dependencies by ecosystem
      const ecosystemGroups = new Map<string, Dependency[]>();
      dependencies.forEach(dep => {
        if (!ecosystemGroups.has(dep.ecosystem)) {
          ecosystemGroups.set(dep.ecosystem, []);
        }
        ecosystemGroups.get(dep.ecosystem)!.push(dep);
      });

      const snykResults: SnykTestResult[] = [];
      
      // Scan each ecosystem group
      for (const [ecosystem, deps] of ecosystemGroups) {
        try {
          const packageManager = this.mapEcosystemToSnykPackageManager(ecosystem);
          if (!packageManager) continue;

          const dependencyMap: Record<string, string> = {};
          deps.forEach(dep => {
            dependencyMap[dep.name] = dep.version;
          });

          const result = await options.snykClient.testDependencies(
            options.snykOrgId || 'default',
            packageManager,
            dependencyMap,
            {
              severityThreshold: options.severityThreshold,
              showVulnPaths: 'some'
            }
          );

          snykResults.push(result);
        } catch (error) {
          console.warn(`Failed to scan ${ecosystem} with Snyk:`, error);
        }
      }

      // Aggregate Snyk results
      const vulnerabilities = snykResults.flatMap(result => result.vulnerabilities);
      const summary = {
        total: snykResults.reduce((sum, result) => sum + result.summary.total, 0),
        critical: snykResults.reduce((sum, result) => sum + result.summary.critical, 0),
        high: snykResults.reduce((sum, result) => sum + result.summary.high, 0),
        medium: snykResults.reduce((sum, result) => sum + result.summary.medium, 0),
        low: snykResults.reduce((sum, result) => sum + result.summary.low, 0)
      };

      return {
        name: 'snyk',
        enabled: true,
        vulnerabilities,
        summary,
        scanDuration: Date.now() - startTime
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Snyk scan failed';
      console.error('Snyk scan error:', error);

      return {
        name: 'snyk',
        enabled: true,
        vulnerabilities: [],
        summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
        scanDuration: Date.now() - startTime,
        error: errorMessage
      };
    }
  }

  private unifyVulnerabilities(sources: VulnerabilitySource[]): UnifiedVulnerability[] {
    const unifiedMap = new Map<string, UnifiedVulnerability>();

    sources.forEach(source => {
      source.vulnerabilities.forEach(vuln => {
        const unified = this.convertToUnifiedVulnerability(vuln, source.name);
        const key = `${unified.packageName}:${unified.id}`;
        
        if (unifiedMap.has(key)) {
          // Merge with existing vulnerability
          const existing = unifiedMap.get(key)!;
          existing.sources.push(...unified.sources);
          
          // Use the highest severity
          if (this.getSeverityWeight(unified.severity) > this.getSeverityWeight(existing.severity)) {
            existing.severity = unified.severity;
          }
          
          // Merge references
          existing.references = [...new Set([...existing.references, ...unified.references])];
        } else {
          unifiedMap.set(key, unified);
        }
      });
    });

    return Array.from(unifiedMap.values());
  }

  private convertToUnifiedVulnerability(vuln: any, sourceName: 'osv' | 'npm-audit' | 'snyk'): UnifiedVulnerability {
    switch (sourceName) {
      case 'osv':
        return this.convertOSVVulnerability(vuln);
      case 'npm-audit':
        return this.convertNpmAuditVulnerability(vuln);
      case 'snyk':
        return this.convertSnykVulnerability(vuln);
      default:
        throw new Error(`Unknown source: ${sourceName}`);
    }
  }

  private convertOSVVulnerability(vuln: OSVVulnerability): UnifiedVulnerability {
    const score = OSVClient.extractSeverityScore(vuln);
    const severity = OSVClient.categorizeSeverity(score);
    const packageInfo = vuln.affected[0]?.package;

    return {
      id: vuln.id,
      title: vuln.summary,
      description: vuln.details || vuln.summary,
      severity,
      packageName: packageInfo?.name || 'unknown',
      packageVersion: 'unknown',
      ecosystem: packageInfo?.ecosystem || 'unknown',
      cvssScore: score || undefined,
      references: vuln.references?.map(ref => ref.url) || [],
      isUpgradable: false, // OSV doesn't provide this info directly
      isPatchable: false,
      publishedDate: vuln.published ? new Date(vuln.published) : undefined,
      modifiedDate: new Date(vuln.modified),
      sources: [{
        name: 'osv',
        id: vuln.id
      }]
    };
  }

  private convertNpmAuditVulnerability(vuln: any): UnifiedVulnerability {
    return {
      id: `npm-${vuln.name}`,
      title: `${vuln.name} vulnerability`,
      description: `Vulnerability in ${vuln.name}`,
      severity: vuln.severity,
      packageName: vuln.name,
      packageVersion: vuln.range,
      ecosystem: 'npm',
      references: [],
      isUpgradable: typeof vuln.fixAvailable === 'object',
      isPatchable: !!vuln.fixAvailable,
      fixedIn: typeof vuln.fixAvailable === 'object' ? vuln.fixAvailable.version : undefined,
      sources: [{
        name: 'npm-audit',
        id: `npm-${vuln.name}`
      }]
    };
  }

  private convertSnykVulnerability(vuln: any): UnifiedVulnerability {
    return {
      id: vuln.id,
      title: vuln.title,
      description: vuln.description,
      severity: vuln.severity,
      packageName: vuln.packageName,
      packageVersion: vuln.version,
      ecosystem: vuln.packageManager || 'unknown',
      cvssScore: vuln.cvssScore,
      cwe: vuln.cwe,
      references: vuln.references || [],
      fixedIn: vuln.fixedIn,
      isUpgradable: vuln.isUpgradable,
      isPatchable: vuln.isPatchable,
      publishedDate: vuln.publishedDate ? new Date(vuln.publishedDate) : undefined,
      modifiedDate: vuln.modificationDate ? new Date(vuln.modificationDate) : undefined,
      sources: [{
        name: 'snyk',
        id: vuln.id
      }]
    };
  }

  private calculateSummary(
    vulnerabilities: UnifiedVulnerability[],
    totalDependencies: number
  ): VulnerabilityAnalysisResult['summary'] {
    const summary = {
      totalVulnerabilities: vulnerabilities.length,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
      fixableCount: 0,
      securityScore: 0,
      riskLevel: 'low' as 'low' | 'medium' | 'high' | 'critical',
      coverageScore: 0
    };

    vulnerabilities.forEach(vuln => {
      summary[`${vuln.severity}Count` as keyof typeof summary]++;
      if (vuln.isUpgradable || vuln.isPatchable) {
        summary.fixableCount++;
      }
    });

    // Calculate security score (0-100, higher is better)
    summary.securityScore = this.calculateSecurityScore(summary);
    
    // Calculate risk level
    summary.riskLevel = this.calculateRiskLevel(summary);
    
    // Calculate coverage score (percentage of dependencies scanned)
    summary.coverageScore = Math.round((vulnerabilities.length / Math.max(totalDependencies, 1)) * 100);

    return summary;
  }

  private calculateSecurityScore(summary: any): number {
    if (summary.totalVulnerabilities === 0) return 100;
    
    const weightedScore = (
      summary.criticalCount * 10 +
      summary.highCount * 7 +
      summary.mediumCount * 4 +
      summary.lowCount * 1
    );
    
    const maxPossibleScore = summary.totalVulnerabilities * 10;
    const score = Math.max(0, 100 - (weightedScore / maxPossibleScore) * 100);
    
    return Math.round(score);
  }

  private calculateRiskLevel(summary: any): 'low' | 'medium' | 'high' | 'critical' {
    if (summary.criticalCount > 0) return 'critical';
    if (summary.highCount > 5) return 'critical';
    if (summary.highCount > 0) return 'high';
    if (summary.mediumCount > 10) return 'high';
    if (summary.mediumCount > 0) return 'medium';
    return 'low';
  }

  private generateRecommendations(
    summary: VulnerabilityAnalysisResult['summary'],
    sources: VulnerabilitySource[],
    projectInfo: ProjectInfo
  ): string[] {
    const recommendations: string[] = [];

    // Critical vulnerabilities
    if (summary.criticalCount > 0) {
      recommendations.push(`ðŸš¨ Address ${summary.criticalCount} critical vulnerabilities immediately`);
    }

    // High vulnerabilities
    if (summary.highCount > 0) {
      recommendations.push(`âš ï¸ Fix ${summary.highCount} high-severity vulnerabilities as soon as possible`);
    }

    // Fixable vulnerabilities
    if (summary.fixableCount > 0) {
      const percentage = Math.round((summary.fixableCount / summary.totalVulnerabilities) * 100);
      recommendations.push(`ðŸ”§ ${summary.fixableCount} vulnerabilities (${percentage}%) can be fixed by updating dependencies`);
    }

    // Security score
    if (summary.securityScore < 70) {
      recommendations.push(`ðŸ“Š Security score is ${summary.securityScore}/100 - consider implementing additional security measures`);
    }

    // Project-specific recommendations
    if (projectInfo.packageManager === 'npm') {
      recommendations.push('ðŸ“¦ Use npm ci and commit package-lock.json for reproducible builds');
    }

    // General security recommendations
    recommendations.push('ðŸ“‹ Add a SECURITY.md file to document security practices');

    // Source-specific recommendations
    const failedSources = sources.filter(s => s.error);
    if (failedSources.length > 0) {
      recommendations.push(`ðŸ” Some vulnerability sources failed: ${failedSources.map(s => s.name).join(', ')}`);
    }

    return recommendations;
  }

  private getSeverityWeight(severity: string): number {
    const weights = { critical: 4, high: 3, medium: 2, low: 1 };
    return weights[severity as keyof typeof weights] || 0;
  }

  private mapEcosystemToSnykPackageManager(ecosystem: string): string | null {
    const mapping: Record<string, string> = {
      'npm': 'npm',
      'pypi': 'pip',
      'maven': 'maven',
      'go': 'go',
      'crates.io': 'cargo',
      'packagist': 'composer',
      'rubygems': 'rubygems',
      'nuget': 'nuget'
    };

    return mapping[ecosystem] || null;
  }

  private updateProgress(progress: AnalysisProgress): void {
    if (this.progressCallback) {
      this.progressCallback(progress);
    }
  }

  // Static utility methods
  static exportResults(results: VulnerabilityAnalysisResult, format: 'json' | 'csv' = 'json'): string {
    if (format === 'json') {
      return JSON.stringify(results, null, 2);
    }

    // CSV format
    const csvRows: string[] = [];
    csvRows.push('Package,Version,Ecosystem,Vulnerability ID,Title,Severity,CVSS Score,Fix Available,Fixed In,Sources,References');

    results.unifiedVulnerabilities.forEach(vuln => {
      const row = [
        vuln.packageName,
        vuln.packageVersion,
        vuln.ecosystem,
        vuln.id,
        `"${vuln.title.replace(/"/g, '""')}"`,
        vuln.severity,
        vuln.cvssScore?.toString() || '',
        vuln.isUpgradable || vuln.isPatchable ? 'Yes' : 'No',
        vuln.fixedIn || '',
        vuln.sources.map(s => s.name).join(';'),
        vuln.references.join(';')
      ].join(',');
      csvRows.push(row);
    });

    return csvRows.join('\n');
  }
}

// Create service instance
export const createVulnerabilityAnalysisService = (
  progressCallback?: (progress: AnalysisProgress) => void
): VulnerabilityAnalysisService => {
  return new VulnerabilityAnalysisService(progressCallback);
};